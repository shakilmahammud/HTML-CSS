<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML and Css Documentation</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<nav id="navbar">
  <header>HTML & CSS Documentation</header>
  <ul> 
    <a class="nav-link" href="#Introduction" rel="internal"><li>Introduction</li></a>
    <a class="nav-link" href="#HTML_Editor" rel="internal"><li>HTML Editor</li></a>
    <a class="nav-link" href="#HTML_Syntex" rel="internal"><li>HMTL Syntex</li></a>
    <a class="nav-link" href="#Element" rel="internal"><li>Element</li></a>
    <a class="nav-link" href="#Examples" rel="internal"><li>Examples</li></a>
    <a class="nav-link" href="#APIs_for_game_development" rel="internal"><li>APIs for game development</li></a>
    <a class="nav-link" href="#Canvas" rel="internal"><li>Canvas</li></a>
    <a class="nav-link" href="#CSS" rel="internal"><li>CSS</li></a>
    <a class="nav-link" href="#Gamepad_API" rel="internal"><li>Gamepad API</li></a>
    <a class="nav-link" href="#Techniques" rel="internal"><li>Techniques</li></a>
    <a class="nav-link" href="#Using_async_scripts_for_asm.js" rel="internal"><li>Using async scripts for asm.js</li></a>
    <a class="nav-link" href="#Optimizing_startup_performance" rel="internal"><li>Optimizing startup performance</li></a>
    <a class="nav-link" href="#Using_WebRTC_peer-to-peer_data_channels" rel="internal"><li>Using WebRTC peer-to-peer data channels</li></a>
    <a class="nav-link" href="#Reference" rel="internal"><li>Reference</li></a>
  </ul>
</nav>
<main id="main-doc">
  <section class="main-section" id="Introduction">
    <header>Introduction</header>
    <article>  
      <p>এইচটিএমএল কি?
        ওয়েব ডকুমেন্টকে বর্ণনা করার জন্য এইচটিএমএল হলো একটি মার্কআপ ল্যাঙ্গুয়েজ।
        <ol>
            <li>HTML এর পূর্নরূপঃ Hyper Text Markup Language।</li>
            <li>মার্কআপ ল্যাঙ্গুয়েজ বলতে একগুচ্ছ মার্কআপ ট্যাগকে বুঝায়।</li>
            <li>এইচটিএমএল ট্যাগ দিয়ে এইচটিএমএল ডকুমেন্ট তৈরি করা হয়।</li>
        </ol>
        </p>

<p>এখন ওয়েব সাইট চিনে না এমন মানুষ খুঁজে পাওয়াই কষ্টর । আমরা প্রতিদিন ফেইসবুক চালাই থাকি এই ফেইসবুক একটা ওয়েব সাইট আর এই ওয়েব সাইট কে ধারণ করে এইচটিএমএল । এইচটিএমএল ওয়েবসাইট এর মা বলা যায়।</p>
      </artice>
    </section>
  <section class="main-section" id="HTML_Editor">
    <header>HTML Editor</header>
    <article>
      <p>এই পাঠ শেষে আপনি জানতে পারবেন কোথায় এইচটিএমএল কোড লিখতে হয় এবং কিভাবে সংরক্ষণ করতে হয়</p>
      <ul>
          <h4>Some code Editor</h4>
          <li>VS code </li>
          <li>Sublime text </li>
          <li>Atom</li>
          <li>Brackets code Editor Etc.</li>
      </ul>
      <p>এখন আপনি যে কোনও একটা এডিটর ইন্সটল করলে পেলেন আপনার কম্পিউটার এ । তার পর ওপেন করন আপানার পছন্দের কোড এডিটর । তার নতুন একটা ফাইল খুলেবেন <br>
        <br>
      <p><img src="images/create-file.png" alt="create-file"></p>
       New File ক্লিক করে একটা file খুলেবন ফাইলের নাম index.html দিন.
       এখন আপনি যা লিখবেন তাই এই ফাইল ব্রাউজার open করলে দেখতে পারবে।
      </p>
      </artice>
    </section>
  <section class="main-section" id="HTML_Syntex">
    <header>Html Syntex</header>
    <article>
    syntex মানে নিয়ম  । প্রতিটা কাজেই একটা নিয়ম থাকে যদি নিয়ম অনুসারে করা হয় কাজ টা সুন্দর হয় ।
    <code>
      &lt;DOCTYPE html&gt;
      &lt;html&gt;


      &lt;head&gt;


      &lt;title&gt;      &lt;/title&gt;

      &lt;/head&gt;


      &lt;body&gt;         &lt;/body&gt;


      &lt;/html&gt;
     
    </code>
    <p>
      এটা হল এইচটিএমএল ফরম্যাট।  
    </p>
    </article>
    </section>
  <section class="main-section" id="Element">
    <header>HTML Element</header>
    <article> 
      <p>html element বা tag</p>
      <ul>
        <p>Tag বা element শুর হয়  <ট্যাগএর নাম >     &lt;/ট্যাগএর নাম&gt; Tag  বা element শেষ</p>
        <p><img src="images/tag.png" alt="tag"></p>
      </ul>
    </article>
    </section>
  <section class="main-section" id="Examples">
    <header>Examples</header>
    <p>Free Demo Games
    </p>
    <li>Beloola</li>
    <li>Tanx</li>
    <li>Hyper Vanguard Force</li>
    <li>Swooop</li>
    <p>Assorted demos
    </p>
    <li>WaveGL</li>
    <li>Canvas Airport Simulation</li>
    <li>Animation Physics</li>
    <li>Volumetric Particle Flow</li>
    <p>Commercial gamesSection
    </p>
    <li>Oort Online</li>
    <li>A Wizard's Lizard</li>
    <li>QbQbQb</li>
    <li>Elliot Quest</li>
     </section>
  <section class="main-section" id="APIs_for_game_development">
    <header>APIs for game development</header>
    <article>
Some of the few APIs are as below:
      <li>Canvas</li>
      <li>CSS</li>
      <li>Full screen</li>
      <li>Gamepad</li>
      <li>Gamepad</li>
    </article>
    </section>
  <section class="main-section" id="Canvas">
    <header>Canvas</header>
    <article>
     <p> Mozilla applications gained support for canvas tag starting with Gecko 1.8 (i.e. Firefox 1.5). The element was originally introduced by Apple for the OS X Dashboard and Safari. Internet Explorer supports canvas
tag from version 9 onwards; for earlier versions of IE, a page can effectively add support for canvas tag by including a script from Google's Explorer Canvas project. Google Chrome and Opera 9 also support canvas tag ..</p>

<p>The canvas element is also used by WebGL to draw hardware-accelerated 3D graphics on web pages.</p>
  Example:
  <p>This is just a simple code snippet which uses the CanvasRenderingContext2D.fillRect() method.</p>
       <p>HTML</p>
<code> canvas id="canvas" canvas </code>
      <p>JavaScript</p>

<code>var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');

ctx.fillStyle = 'green';
ctx.fillRect(10, 10, 100, 100);</code>
    </article>
    </section>
  <section class="main-section" id="CSS">
    <header>CSS</header>
    <article>
<p>CSS is one of the core languages of the open web and is standardized across browsers according to the W3C specification. Developed in levels, CSS1 is now obsolete, CSS2.1 is a recommendation, and CSS3, now split into smaller modules, is progressing on the standardization track.</p>

<p>This module starts with the basics of how CSS works, including selectors and properties, writing CSS rules, applying CSS to HTML, how to specify length, color, and other units in CSS, cascade and inheritance, box model basics, and debugging CSS.</p>
    </article>
    </section>
  <section class="main-section" id="Gamepad_API">
    <header> Gamepad API </header>
    <article>
<p>The Gamepad API is a way for developers to access and respond to signals from gamepads and other game controllers in a simple, consistent way. It contains three interfaces, two events and one specialist function, to respond to gamepads being connected and disconnected, and to access other information about the gamepads themselves, and what buttons and other controls are currently being pressed.</p>

      <h4>Interfaces</h4> 
<p>Gamepad:
Represents a gamepad/controller connected to the computer.
  
GamepadButton:
Represents a button on one of the connected controllers.
  
GamepadEvent:
The event object representing events fired that are related to gamepads.</p>
      <h4>Experimental Gamepad extensions</h4>
<p>GamepadHapticActuator:
Represents hardware in the controller designed to provide haptic feedback to the user (if available), most commonly vibration hardware.
  
GamepadPose:
Represents the pose of a controller (e.g. position and orientation in 3D space) in the case of a WebVRcontroller.
  
See also the extensions to the Gamepad interface, for features that allow you to access the above information.</p>

<p>You cannot declare a constant with the same name as a function or variable in the same scope. For example:</p>
      <h4>Extensions to other interfaces</h4>
      <p>
Navigator
        
Navigator.getGamepads():
An extension to the Navigator object that returns an array of Gamepad objects, one for each connected gamepad.
Window events
        
Window.ongamepadconnected:
Represents an event handler that will run when a gamepad is connected (when the gamepadconnected event fires).
        
Window.ongamepaddisconnected:
Represents an event handler that will run when a gamepad is disconnected (when the gamepaddisconnected event fires).</p>
    </article>
    </section>
  <section class="main-section" id="Techniques">
    <header>Techniques</header>
    <article>
      <p>There are so many techniques and some of them are discussed as below:
      </p>
    
   <li>Using async scripts for asm.js.</li>
   <li>Optimizing startup performance.</li>
  <li>Using WebRTC peer-to-peer data               channels.</li>
  <li>Efficient animation for web games.</li>
  <li>Audio for Web Games</li>
  <li>2D collision detection.</li>
   <li>Tiles and tilemaps overview</li>
    </article>
    </section>
  <section class="main-section" id="Using_async_scripts_for_asm.js">
    <header>Using async scripts for asm.js</header>
    <article>
<h3>Putting async into action</h3>
<p>Getting async compilation is easy: when writing your JavaScript, just use the async attribute like so:</p>
<code>script async src="file.js"> script</code>
      <p>or, to do the same thing via script:</p>
      <code>var script = document.createElement('script');
script.src = "file.js";
document.body.appendChild(script);</code>
      <h3>When is async not async?</h3>
<p>Two common situations in which a script is *not* async (as defined by the HTML spec) are:</p>
<code>script async code /script</code>
      <p>and</p>
      <code>var script = document.createElement('script');
script.innerHTML = "code";
document.body.appendChild(script);</code>
      <p>Both are counted as 'inline' scripts and get compiled and then run immediately.

What if your code is in a JS string? Instead of using eval or innerHTML, both of which trigger synchronous compilation, you should use a Blob with an object URL:</p>
      <code>var blob = new Blob([codeString]);
var script = document.createElement('script');
var url = URL.createObjectURL(blob);
script.onload = script.onerror = function() { URL.revokeObjectURL(url); };
script.src = url;
document.body.appendChild(script);</code>
      
    </article>
    </section>
  <section class="main-section" id="Optimizing_startup_performance">
    <header>Optimizing startup performance</header>
    <article>
<h3>Starting up nicely</h3>
      <p>Regardless of platform, it's always a good idea to start up as quickly as possible. Since that's a universal issue, we won't be focusing on it too much here. Instead, we're going to look at a more important issue when building Web apps: starting up as asynchronously as possible. That means not running all your startup code in a single event handler on the app's main thread.</p>
      <p>Why is it important to be asynchronous? Other than the reasons suggested above, consider the impact of a non-responsive page or user interface. The user is unable to cancel if they launched your app by mistake. If the app is being run in a browser, it's possible the user may get an "unresponsive app" or "slow script" notification. You should present some kind of interface, such as a progress bar, so that the user knows how much longer they'll need to wait while your app starts up.
</p>
      <h3>Where there's a will...</h3>
      <p>If you're starting your project from scratch, it's usually pretty easy to just write everything the "right way," making appropriate bits of the code asynchronous. All pure startup calculations should be performed in background threads, while you keep the run-time of main thread events as short as possible. Include a progress indicator so the user knows what's going on and how long they'll be waiting. In theory, anyway, it should be pretty easy to design your new app to start up nicely.</p>
      <p>While you can use Web workers to run even very large, long-duration chunks of JavaScript code asynchronously, there's a huge caveat that: workers don't have access to WebGL or audio, and they can't send synchronous messages to the main thread, so you can't even proxy those APIs to the main thread. This all means that unless you can easily pull out the "pure calculation" chunks of your startup process into workers, you'll wind up having to run most or all of your startup code on the main thread.</p>
      <p>When that part of the document needs to be rendered, load the commented HTML.</p>
<code>foo.innerHTML = foo.firstChild.nodeValue;</code>

    </article>
    </section>
  <section class="main-section" id="Using_WebRTC_peer-to-peer_data_channels">
    <header>Using WebRTC peer-to-peer data channels</header>
    <article> 
      <h3>What is a data channel?</h3>
      <p>A WebRTC data channel lets you send text or binary data over an active connection to a peer. In the context of a game, this lets players send data to each other, whether text chat or game status information. Data channels come in two flavors.</p>
      <p>Reliable channels guarantee that messages you send arrive at the other peer and in the same order in which they're sent. This is analogous to a TCP socket.</p>
      <p>Unreliable channels make no such guarantees; messages aren't guaranteed to arrive in any particular order and, in fact, aren't guaranteed to arrive at all. This is analogous to a UDP socket.</p>
      <p>We have documentation for using WebRTC. This article, however, will take advantage of some libraries that can help trivialize the work, and will demonstrate ways to use abstraction to work around implementation differences between browsers. Hopefully, of course, those differences will fade away in time.</p>
      <h3>Using the p2p library</h3>
      <p>One library you can use is the p2p library. This library provides a simple API for creating peer connections and setting up streams and data channels. There's also a broker server component and a hosted broker you can use instead of having to set one up for yourself.</p>
    </article>
    </section>
  <section class="main-section" id="Reference">
    <header>Reference</header>
    <article>
      <li>All the documentation in this page is taken from <a href="https://developer.mozilla.org/en-US/docs/Games" target="_blank">MDN</a>
    </article>
    </section>
  </main>
</body>
</html>